#!/usr/bin/perl
use strict;

{
    # Event class
    package InputEvent;
    require IO::File;
    use Config;

    my $struct_len = ($Config{longsize} * 2) +
                     ($Config{i16size} * 2) +
                     ($Config{i32size});
    
    # type name -> type number
    our %type = ();
    # event name -> event number
    our %code = ();
    # (type number, event number) -> event name
    our %ev_dict = ();

    sub load_constants {
        my $proto = shift;
        my $class = ref($proto) || $proto;

        my $filename = shift;

        my $fh = new IO::File($filename, "r");
        while (my $line = <$fh>) {
            my ($string, $number) = split(/[[:space:]]+/, $line);
            $number = hex($number) if $number =~ /^0x/;

            my ($prefix, $desc) = split(/_/, $string, 2);
            if ($prefix eq "EV") {
                $type{$string} = $number;
            } else {
                $code{$string} = { type => "EV_".$prefix, code => $number };
                
                my $type_code = $type{"EV_".$prefix};
                $ev_dict{$type_code}{$number} = { event => $string, type => "EV_".$prefix };
            }
        }
        $fh->close();
        return 1;
    }


    sub new {
        my $proto = shift;
        my $class = ref($proto) || $proto;
        my $self = {};

        if (@_ == 3) {
            $self->{TYPE} = shift;
            $self->{CODE} = shift;
            $self->{VALUE} = shift;
        } else {
            return undef;
        }

        bless($self, $class);
    }

    sub read_from_filehandle {
        my $proto = shift;
        my $class = ref($proto) || $proto;
        
        my $fh = shift;
        
        my $buffer;
        my $len = sysread($fh, $buffer, $struct_len);
        return undef unless $len > 0;
        
        my ($sec, $usec, $type, $code, $value) = unpack('L!L!S!S!i!', $buffer);

        return $class->new($type, $code, $value);
    }

    sub type { return shift()->{TYPE}; }
    sub code { return shift()->{CODE}; }
    sub value { return shift()->{VALUE}; }

    sub name {
        my $self = shift;
        return $ev_dict{$self->type}{$self->code}{event};
    }

    sub type_description {
        my $self = shift;
        return $ev_dict{$self->type}{$self->code}{type};
    }


    sub matches {
        my $self = shift;
        my $other = shift;

        return ($self->type == $other->type &&
                $self->code == $other->code &&
                $self->value== $other->value);
    }

    sub as_string {
        my $self = shift;
        return "InputEvent ",$self->type,"/",$self->code," (", $self->name, ") with value ", $self->value;
    }
} 

{
    package DeviceWatcher;
    # abstract class
    sub new {
        my $proto = shift;
        my $class = ref($proto) || $proto;
        bless( {}, $class );
    }

    # add or remove handles
    sub add_filehandle { }
    sub remove_filehandle { }
    # start main loop
    sub watch { }

    # read an event from a given filehandle and process it
    sub process_filehandle {
        my $self = shift;
        my $fh = shift;
        my $ie = InputEvent->read_from_filehandle($fh);
        
        unless (defined $ie) {
            print "Error reading from filehandle, removing\n";
            $self->remove_filehandle($fh);
            return;
        } 

        if ($ie->type_description eq "EV_KEY" || $ie->type_description eq "EV_SW") {
            print $ie->as_string, "\n";
        }
    }

}

{
    package SelectDeviceWatcher;
    our @ISA = ("DeviceWatcher");

    require IO::File;
    require IO::Select;

    sub new {
        my $proto = shift;
        my $class = ref($proto) || $proto;
        my $self = {};
        
        $self->{SELECTOR} = new IO::Select;
        
        bless($self, $class);
    }

    sub add_filehandle {
        my $self = shift;
        my $dev = shift;
        $self->{SELECTOR}->add($dev);
    }

    sub remove_filehandle {
        my $self = shift;
        my $fh = shift;
        $self->SUPER::remove_filehandle($fh);
        print "Removing filehandle ", $fh->fileno, " from selector\n";
        $self->{SELECTOR}->remove($fh);
    }

    sub watch {
        my $self = shift;
        my $sel = $self->{SELECTOR};
        while(my @ready = $sel->can_read) {
            for my $fh (@ready) {
                $self->process_filehandle($fh);
            }
            return unless $sel->count > 0;
        }
    }

}

{
    package DBusDeviceWatcher;
    our @ISA = ("DeviceWatcher");

    sub new {
        require Net::DBus;
        require Net::DBus::Reactor;
        my $proto = shift;
        my $class = ref($proto) || $proto;
        my $self = $class->SUPER::new();

        $self->{REACTOR} = Net::DBus::Reactor->main;
        
        bless($self, $class);
    }

    sub add_filehandle {
        my $self = shift;
        my $dev = shift;

        my $read_cb = sub {
            my $fh = shift;
            $self->process_filehandle($fh);
        };

        $self->{REACTOR}->add_read( 
            $dev->fileno,
            Net::DBus::Callback->new(
                method => $read_cb,
                args   => [$dev]
            ),
            1
        );
    }

    sub remove_filehandle {
        my $self = shift;
        my $dev = shift;
        print "Removing read handler from reactor\n";
        $self->{REACTOR}->remove_read($dev->fileno);
    }

    sub cb_device_added {
        my $self = shift;
        my $device_id = shift;
        my $dev = $self->{hal}->get_object($device_id, 'org.freedesktop.Hal.Device');
        my $props = $dev->GetAllProperties;
        if ($props->{"linux.subsystem"} eq "input") {
            # check input capabilities
            # only watch devices with keys, switches or buttons
            for my $cap (@{$props->{"info.capabilities"}}) {
                if ($cap eq "input.keyboard" ||
                    $cap eq "input.keypad" ||
                    $cap eq "input.keys" ||
                    $cap eq "input.switch" ||
                    $cap eq "buttons") {
                    
                    $self->add_filehandle(new IO::File($props->{"input.device"}, 'r'));

                    last;
                }
            }
        }
    }

    sub watch {
        my $self = shift;
        # install hotplug listener
        my $bus = Net::DBus->system;
        $self->{hal} = $bus->get_service("org.freedesktop.Hal");
        my $manager = $self->{hal}->get_object("/org/freedesktop/Hal/Manager", "org.freedesktop.Hal.Manager");
        # add all existing devices
        foreach my $id (@{$manager->GetAllDevices}) {
            $self->cb_device_added($id);
        }

        # register device added callback
        $manager->connect_to_signal("DeviceAdded", sub {$self->cb_device_added(shift)} );

        # start main loop
        $self->{REACTOR}->run();
    }
}

InputEvent->load_constants(shift @ARGV);

my $watcher = new DBusDeviceWatcher();
for (@ARGV) {
    $watcher->add_filehandle(new IO::File($_, 'r'));
}
$watcher->watch();
